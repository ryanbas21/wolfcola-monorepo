import * as Cause from "effect/Cause";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import * as Exit from "effect/Exit";
import { flow, identity, pipe } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Logger from "effect/Logger";
import * as Schedule from "effect/Schedule";
import * as TestEnvironment from "effect/TestContext";
import * as Utils from "effect/Utils";
import * as V from "vitest";
/** @internal */
const runTest = effect => Effect.gen(function* () {
  const exit = yield* Effect.exit(effect);
  if (Exit.isSuccess(exit)) {
    return () => {};
  } else {
    const errors = Cause.prettyErrors(exit.cause);
    for (let i = 1; i < errors.length; i++) {
      yield* Effect.logError(errors[i]);
    }
    return () => {
      throw errors[0];
    };
  }
}).pipe(Effect.runPromise).then(f => f());
/** @internal */
const TestEnv = /*#__PURE__*/TestEnvironment.TestContext.pipe( /*#__PURE__*/Layer.provide( /*#__PURE__*/Logger.remove(Logger.defaultLogger)));
/** @internal */
function customTester(a, b, customTesters) {
  if (!Equal.isEqual(a) || !Equal.isEqual(b)) {
    return undefined;
  }
  return Utils.structuralRegion(() => Equal.equals(a, b), (x, y) => this.equals(x, y, customTesters.filter(t => t !== customTester)));
}
/** @internal */
export const addEqualityTesters = () => {
  V.expect.addEqualityTesters([customTester]);
};
/** @internal */
const makeTester = mapEffect => {
  const run = self => (...args) => pipe(Effect.suspend(() => self(...args)), mapEffect, runTest);
  const f = (name, self, timeout) => V.it(name, run(self), timeout);
  const skip = (name, self, timeout) => V.it.skip(name, run(self), timeout);
  const skipIf = condition => (name, self, timeout) => V.it.skipIf(condition)(name, run(self), timeout);
  const only = (name, self, timeout) => V.it.only(name, run(self), timeout);
  const each = cases => (name, self, timeout) => V.it.each(cases)(name, run(self), timeout);
  return Object.assign(f, {
    skip,
    skipIf,
    only,
    each
  });
};
/** @internal */
export const effect = /*#__PURE__*/makeTester( /*#__PURE__*/Effect.provide(TestEnv));
/** @internal */
export const scoped = /*#__PURE__*/makeTester( /*#__PURE__*/flow(Effect.scoped, /*#__PURE__*/Effect.provide(TestEnv)));
/** @internal */
export const live = /*#__PURE__*/makeTester(identity);
/** @internal */
export const scopedLive = /*#__PURE__*/makeTester(Effect.scoped);
/** @internal */
export const flakyTest = (self, timeout = Duration.seconds(30)) => pipe(Effect.catchAllDefect(self, Effect.fail), Effect.retry(pipe(Schedule.recurs(10), Schedule.compose(Schedule.elapsed), Schedule.whileOutput(Duration.lessThanOrEqualTo(timeout)))), Effect.orDie);
//# sourceMappingURL=internal.js.map