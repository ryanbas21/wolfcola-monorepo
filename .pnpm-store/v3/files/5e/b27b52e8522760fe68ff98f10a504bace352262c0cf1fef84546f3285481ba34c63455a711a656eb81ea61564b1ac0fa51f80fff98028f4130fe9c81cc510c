"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = exports.layerMessagePort = exports.layer = void 0;
var _WorkerError = require("@effect/platform/WorkerError");
var Runner = _interopRequireWildcard(require("@effect/platform/WorkerRunner"));
var Deferred = _interopRequireWildcard(require("effect/Deferred"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var ExecStrategy = _interopRequireWildcard(require("effect/ExecutionStrategy"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var FiberId = _interopRequireWildcard(require("effect/FiberId"));
var FiberSet = _interopRequireWildcard(require("effect/FiberSet"));
var _GlobalValue = require("effect/GlobalValue");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Scope = _interopRequireWildcard(require("effect/Scope"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const cachedPorts = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/platform-browser/Worker/cachedPorts", () => new Set());
function globalHandleConnect(event) {
  cachedPorts.add(event.ports[0]);
}
if (typeof self !== "undefined" && "onconnect" in self) {
  self.onconnect = globalHandleConnect;
}
/** @internal */
const make = self => Runner.PlatformRunner.of({
  [Runner.PlatformRunnerTypeId]: Runner.PlatformRunnerTypeId,
  start() {
    return Effect.sync(() => {
      let currentPortId = 0;
      const ports = new Map();
      const send = (portId, message, transfer) => Effect.sync(() => {
        ;
        (ports.get(portId)?.[0] ?? self).postMessage([1, message], {
          transfer: transfer
        });
      });
      const run = handler => Effect.uninterruptibleMask(restore => Scope.make().pipe(Effect.bindTo("scope"), Effect.bind("fiberSet", ({
        scope
      }) => FiberSet.make().pipe(Scope.extend(scope))), Effect.bind("runFork", ({
        fiberSet
      }) => FiberSet.runtime(fiberSet)()), Effect.tap(({
        fiberSet,
        runFork,
        scope
      }) => {
        function onMessage(portId) {
          return function (event) {
            const message = event.data;
            if (message[0] === 0) {
              runFork(restore(handler(portId, message[1])));
            } else {
              const port = ports.get(portId);
              if (port) {
                Effect.runFork(Scope.close(port[1], Exit.void));
              }
              ports.delete(portId);
              if (ports.size === 0) {
                Deferred.unsafeDone(fiberSet.deferred, Exit.interrupt(FiberId.none));
              }
            }
          };
        }
        function onMessageError(error) {
          Deferred.unsafeDone(fiberSet.deferred, new _WorkerError.WorkerError({
            reason: "decode",
            cause: error.data
          }));
        }
        function onError(error) {
          Deferred.unsafeDone(fiberSet.deferred, new _WorkerError.WorkerError({
            reason: "unknown",
            cause: error.data
          }));
        }
        function handlePort(port) {
          return Scope.fork(scope, ExecStrategy.sequential).pipe(Effect.flatMap(scope => {
            const portId = currentPortId++;
            ports.set(portId, [port, scope]);
            const onMsg = onMessage(portId);
            port.addEventListener("message", onMsg);
            port.addEventListener("messageerror", onMessageError);
            if ("start" in port) {
              port.start();
            }
            port.postMessage([0]);
            return Scope.addFinalizer(scope, Effect.sync(() => {
              port.removeEventListener("message", onMsg);
              port.removeEventListener("messageerror", onError);
            }));
          }), runFork);
        }
        self.addEventListener("error", onError);
        let prevOnConnect;
        if ("onconnect" in self) {
          prevOnConnect = self.onconnect;
          self.onconnect = function (event) {
            const port = event.ports[0];
            handlePort(port);
          };
          for (const port of cachedPorts) {
            handlePort(port);
          }
          cachedPorts.clear();
        } else {
          handlePort(self);
        }
        return Scope.addFinalizer(scope, Effect.sync(() => {
          self.removeEventListener("error", onError);
          if ("onconnect" in self) {
            self.onconnect = prevOnConnect;
          }
          self.close();
        }));
      }), Effect.flatMap(({
        fiberSet,
        scope
      }) => restore(FiberSet.join(fiberSet)).pipe(Effect.ensuring(Scope.close(scope, Exit.void))))));
      return {
        run,
        send
      };
    });
  }
});
/** @internal */
exports.make = make;
const layerMessagePort = port => Layer.succeed(Runner.PlatformRunner, make(port));
/** @internal */
exports.layerMessagePort = layerMessagePort;
const layer = exports.layer = /*#__PURE__*/Layer.sync(Runner.PlatformRunner, () => make(self));
//# sourceMappingURL=workerRunner.js.map