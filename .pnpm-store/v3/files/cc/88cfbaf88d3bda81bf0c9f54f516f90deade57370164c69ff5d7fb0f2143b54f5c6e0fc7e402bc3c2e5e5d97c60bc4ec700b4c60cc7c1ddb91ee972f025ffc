"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withXHRArrayBuffer = exports.makeXMLHttpRequest = exports.layerXMLHttpRequest = exports.currentXMLHttpRequest = exports.currentXHRResponseType = exports.IncomingMessageImpl = void 0;
var Cookies = _interopRequireWildcard(require("@effect/platform/Cookies"));
var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
var Client = _interopRequireWildcard(require("@effect/platform/HttpClient"));
var Error = _interopRequireWildcard(require("@effect/platform/HttpClientError"));
var ClientResponse = _interopRequireWildcard(require("@effect/platform/HttpClientResponse"));
var IncomingMessage = _interopRequireWildcard(require("@effect/platform/HttpIncomingMessage"));
var UrlParams = _interopRequireWildcard(require("@effect/platform/UrlParams"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
var _GlobalValue = require("effect/GlobalValue");
var Inspectable = _interopRequireWildcard(require("effect/Inspectable"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Option = _interopRequireWildcard(require("effect/Option"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var HeaderParser = _interopRequireWildcard(require("multipasta/HeadersParser"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/** @internal */
const currentXMLHttpRequest = exports.currentXMLHttpRequest = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/platform-browser/BrowserHttpClient/currentXMLHttpRequest", () => FiberRef.unsafeMake(() => new XMLHttpRequest()));
/** @internal */
const currentXHRResponseType = exports.currentXHRResponseType = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/platform-browser/BrowserHttpClient/currentXHRResponseType", () => FiberRef.unsafeMake("text"));
/** @internal */
const withXHRArrayBuffer = effect => Effect.locally(effect, currentXHRResponseType, "arraybuffer");
/** @internal */
exports.withXHRArrayBuffer = withXHRArrayBuffer;
const makeXMLHttpRequest = exports.makeXMLHttpRequest = /*#__PURE__*/Client.makeDefault((request, url, signal, fiber) => Effect.suspend(() => {
  const xhr = fiber.getFiberRef(currentXMLHttpRequest)();
  signal.addEventListener("abort", () => {
    xhr.abort();
    xhr.onreadystatechange = null;
  }, {
    once: true
  });
  xhr.open(request.method, url.toString(), true);
  xhr.responseType = fiber.getFiberRef(currentXHRResponseType);
  Object.entries(request.headers).forEach(([k, v]) => {
    xhr.setRequestHeader(k, v);
  });
  return Effect.zipRight(sendBody(xhr, request), Effect.async(resume => {
    let sent = false;
    const onChange = () => {
      if (!sent && xhr.readyState >= 2) {
        sent = true;
        resume(Effect.succeed(new ClientResponseImpl(request, xhr)));
      }
    };
    xhr.onreadystatechange = onChange;
    xhr.onerror = _event => {
      resume(Effect.fail(new Error.RequestError({
        request,
        reason: "Transport",
        cause: xhr.statusText
      })));
    };
    onChange();
  }));
}));
const sendBody = (xhr, request) => {
  const body = request.body;
  switch (body._tag) {
    case "Empty":
      return Effect.sync(() => xhr.send());
    case "Raw":
      return Effect.sync(() => xhr.send(body.body));
    case "Uint8Array":
      return Effect.sync(() => xhr.send(body.body));
    case "FormData":
      return Effect.sync(() => xhr.send(body.formData));
    case "Stream":
      return Effect.matchEffect(Stream.runFold(body.stream, new Uint8Array(0), (acc, chunk) => {
        const next = new Uint8Array(acc.length + chunk.length);
        next.set(acc, 0);
        next.set(chunk, acc.length);
        return next;
      }), {
        onFailure: cause => Effect.fail(new Error.RequestError({
          request,
          reason: "Encode",
          cause
        })),
        onSuccess: body => Effect.sync(() => xhr.send(body))
      });
  }
};
const encoder = /*#__PURE__*/new TextEncoder();
/** @internal */
class IncomingMessageImpl extends Inspectable.Class {
  source;
  onError;
  [IncomingMessage.TypeId];
  constructor(source, onError) {
    super();
    this.source = source;
    this.onError = onError;
    this[IncomingMessage.TypeId] = IncomingMessage.TypeId;
    this._rawHeaderString = source.getAllResponseHeaders();
  }
  _rawHeaderString;
  _rawHeaders;
  _headers;
  get headers() {
    if (this._headers) {
      return this._headers;
    }
    if (this._rawHeaderString === "") {
      return this._headers = Headers.empty;
    }
    const parser = HeaderParser.make();
    const result = parser(encoder.encode(this._rawHeaderString + "\r\n"), 0);
    this._rawHeaders = result._tag === "Headers" ? result.headers : undefined;
    const parsed = result._tag === "Headers" ? Headers.fromInput(result.headers) : Headers.empty;
    return this._headers = parsed;
  }
  cachedCookies;
  get cookies() {
    if (this.cachedCookies) {
      return this.cachedCookies;
    }
    this.headers;
    if (this._rawHeaders === undefined) {
      return Cookies.empty;
    } else if (this._rawHeaders["set-cookie"] === undefined) {
      return this.cachedCookies = Cookies.empty;
    }
    return this.cachedCookies = Cookies.fromSetCookie(this._rawHeaders["set-cookie"]);
  }
  get remoteAddress() {
    return Option.none();
  }
  _textEffect;
  get text() {
    if (this._textEffect) {
      return this._textEffect;
    }
    return this._textEffect = Effect.async(resume => {
      if (this.source.readyState === 4) {
        resume(Effect.succeed(this.source.responseText));
        return;
      }
      const onReadyStateChange = () => {
        if (this.source.readyState === 4) {
          resume(Effect.succeed(this.source.responseText));
        }
      };
      const onError = () => {
        resume(Effect.fail(this.onError(this.source.statusText)));
      };
      this.source.addEventListener("readystatechange", onReadyStateChange);
      this.source.addEventListener("error", onError);
      return Effect.sync(() => {
        this.source.removeEventListener("readystatechange", onReadyStateChange);
        this.source.removeEventListener("error", onError);
      });
    }).pipe(Effect.cached, Effect.runSync);
  }
  get json() {
    return Effect.tryMap(this.text, {
      try: _ => _ === "" ? null : JSON.parse(_),
      catch: this.onError
    });
  }
  get urlParamsBody() {
    return Effect.flatMap(this.text, _ => Effect.try({
      try: () => UrlParams.fromInput(new URLSearchParams(_)),
      catch: this.onError
    }));
  }
  get stream() {
    return Stream.async(emit => {
      let offset = 0;
      const onReadyStateChange = () => {
        if (this.source.readyState === 3) {
          emit.single(encoder.encode(this.source.responseText.slice(offset)));
          offset = this.source.responseText.length;
        } else if (this.source.readyState === 4) {
          if (offset < this.source.responseText.length) {
            emit.single(encoder.encode(this.source.responseText.slice(offset)));
          }
          emit.end();
        }
      };
      const onError = () => {
        emit.fail(this.onError(this.source.statusText));
      };
      this.source.addEventListener("readystatechange", onReadyStateChange);
      this.source.addEventListener("error", onError);
      onReadyStateChange();
      return Effect.sync(() => {
        this.source.removeEventListener("readystatechange", onReadyStateChange);
        this.source.removeEventListener("error", onError);
      });
    });
  }
  _arrayBufferEffect;
  get arrayBuffer() {
    if (this.source.responseType !== "arraybuffer") {
      return Effect.fail(this.onError(new globalThis.Error("xhr.responseType is not arraybuffer")));
    }
    if (this._arrayBufferEffect) {
      return this._arrayBufferEffect;
    }
    return this._arrayBufferEffect = Effect.async(resume => {
      if (this.source.readyState === 4) {
        resume(Effect.succeed(this.source.response));
        return;
      }
      const onReadyStateChange = () => {
        if (this.source.readyState === 4) {
          resume(Effect.succeed(this.source.response));
        }
      };
      const onError = () => {
        resume(Effect.fail(this.onError(this.source.statusText)));
      };
      this.source.addEventListener("readystatechange", onReadyStateChange);
      this.source.addEventListener("error", onError);
      return Effect.sync(() => {
        this.source.removeEventListener("readystatechange", onReadyStateChange);
        this.source.removeEventListener("error", onError);
      });
    }).pipe(Effect.map(response => {
      if (typeof response === "string") {
        return encoder.encode(response).buffer;
      }
      return response;
    }), Effect.cached, Effect.runSync);
  }
}
exports.IncomingMessageImpl = IncomingMessageImpl;
class ClientResponseImpl extends IncomingMessageImpl {
  request;
  [ClientResponse.TypeId];
  constructor(request, source) {
    super(source, cause => new Error.ResponseError({
      request,
      response: this,
      reason: "Decode",
      cause
    }));
    this.request = request;
    this[ClientResponse.TypeId] = ClientResponse.TypeId;
  }
  get status() {
    return this.source.status;
  }
  get formData() {
    return Effect.die("Not implemented");
  }
  toString() {
    return `ClientResponse(${this.status})`;
  }
  toJSON() {
    let body;
    try {
      body = Effect.runSync(this.json);
    } catch (_) {
      //
    }
    try {
      body = body ?? Effect.runSync(this.text);
    } catch (_) {
      //
    }
    return {
      _id: "@effect/platform/HttpClientResponse",
      request: this.request.toJSON(),
      status: this.status,
      headers: this.headers,
      remoteAddress: this.remoteAddress.toJSON(),
      body
    };
  }
}
/** @internal */
const layerXMLHttpRequest = exports.layerXMLHttpRequest = /*#__PURE__*/Layer.succeed(Client.HttpClient, makeXMLHttpRequest);
//# sourceMappingURL=httpClient.js.map