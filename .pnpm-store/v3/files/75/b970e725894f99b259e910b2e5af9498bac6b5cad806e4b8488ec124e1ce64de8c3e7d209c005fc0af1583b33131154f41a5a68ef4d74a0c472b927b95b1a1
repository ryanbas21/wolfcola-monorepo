import { WorkerError } from "@effect/platform/WorkerError";
import * as Runner from "@effect/platform/WorkerRunner";
import * as Deferred from "effect/Deferred";
import * as Effect from "effect/Effect";
import * as ExecStrategy from "effect/ExecutionStrategy";
import * as Exit from "effect/Exit";
import * as FiberId from "effect/FiberId";
import * as FiberSet from "effect/FiberSet";
import { globalValue } from "effect/GlobalValue";
import * as Layer from "effect/Layer";
import * as Scope from "effect/Scope";
const cachedPorts = /*#__PURE__*/globalValue("@effect/platform-browser/Worker/cachedPorts", () => new Set());
function globalHandleConnect(event) {
  cachedPorts.add(event.ports[0]);
}
if (typeof self !== "undefined" && "onconnect" in self) {
  self.onconnect = globalHandleConnect;
}
/** @internal */
export const make = self => Runner.PlatformRunner.of({
  [Runner.PlatformRunnerTypeId]: Runner.PlatformRunnerTypeId,
  start() {
    return Effect.sync(() => {
      let currentPortId = 0;
      const ports = new Map();
      const send = (portId, message, transfer) => Effect.sync(() => {
        ;
        (ports.get(portId)?.[0] ?? self).postMessage([1, message], {
          transfer: transfer
        });
      });
      const run = handler => Effect.uninterruptibleMask(restore => Scope.make().pipe(Effect.bindTo("scope"), Effect.bind("fiberSet", ({
        scope
      }) => FiberSet.make().pipe(Scope.extend(scope))), Effect.bind("runFork", ({
        fiberSet
      }) => FiberSet.runtime(fiberSet)()), Effect.tap(({
        fiberSet,
        runFork,
        scope
      }) => {
        function onMessage(portId) {
          return function (event) {
            const message = event.data;
            if (message[0] === 0) {
              runFork(restore(handler(portId, message[1])));
            } else {
              const port = ports.get(portId);
              if (port) {
                Effect.runFork(Scope.close(port[1], Exit.void));
              }
              ports.delete(portId);
              if (ports.size === 0) {
                Deferred.unsafeDone(fiberSet.deferred, Exit.interrupt(FiberId.none));
              }
            }
          };
        }
        function onMessageError(error) {
          Deferred.unsafeDone(fiberSet.deferred, new WorkerError({
            reason: "decode",
            cause: error.data
          }));
        }
        function onError(error) {
          Deferred.unsafeDone(fiberSet.deferred, new WorkerError({
            reason: "unknown",
            cause: error.data
          }));
        }
        function handlePort(port) {
          return Scope.fork(scope, ExecStrategy.sequential).pipe(Effect.flatMap(scope => {
            const portId = currentPortId++;
            ports.set(portId, [port, scope]);
            const onMsg = onMessage(portId);
            port.addEventListener("message", onMsg);
            port.addEventListener("messageerror", onMessageError);
            if ("start" in port) {
              port.start();
            }
            port.postMessage([0]);
            return Scope.addFinalizer(scope, Effect.sync(() => {
              port.removeEventListener("message", onMsg);
              port.removeEventListener("messageerror", onError);
            }));
          }), runFork);
        }
        self.addEventListener("error", onError);
        let prevOnConnect;
        if ("onconnect" in self) {
          prevOnConnect = self.onconnect;
          self.onconnect = function (event) {
            const port = event.ports[0];
            handlePort(port);
          };
          for (const port of cachedPorts) {
            handlePort(port);
          }
          cachedPorts.clear();
        } else {
          handlePort(self);
        }
        return Scope.addFinalizer(scope, Effect.sync(() => {
          self.removeEventListener("error", onError);
          if ("onconnect" in self) {
            self.onconnect = prevOnConnect;
          }
          self.close();
        }));
      }), Effect.flatMap(({
        fiberSet,
        scope
      }) => restore(FiberSet.join(fiberSet)).pipe(Effect.ensuring(Scope.close(scope, Exit.void))))));
      return {
        run,
        send
      };
    });
  }
});
/** @internal */
export const layerMessagePort = port => Layer.succeed(Runner.PlatformRunner, make(port));
/** @internal */
export const layer = /*#__PURE__*/Layer.sync(Runner.PlatformRunner, () => make(self));
//# sourceMappingURL=workerRunner.js.map